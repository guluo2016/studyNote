分段提交算法可以解决分布式系统的事务问题，目前常用的是2PC算法和3PC算法。

#### 1 2PC算法
2PC算法思想，将分布式系统中的节点分为2类角色：协调者和参与者。

- 协调者，整个系统中只有一个，负责发起任务，询问参与者，向参与者发送执行命令
- 参与者，有多个，负责响应协调者，执行协调者发送过来的命令

整个2PC算法，分为2个阶段：  

- 1阶段（请求阶段）：协调者向参与者发送询问请求，循环对于某一任务是否可以执行；参与者收到询问请求之后，根据实际情况向协调者返回同意或者失败的响应   
- 2阶段（提交阶段）：协调者会一直等待，知道接收到所有参与者的响应。当协调者收到所有参与者的同意响应之后，就会向参与者发送任务执行的请求。当收到的响应中包含不同意的话，那么协调者就终止本次事务。  



2PC算法存在的问题：   

1. 协调者需要一直等待，直至接收到所有参与者的响应，在此期间，存在如些问题
   1. 如果参与者故障迟迟不能响应协调者，那么协调者就会陷入阻塞等待
   2. 如果协调者故障，那么所有参与者都陷入阻塞等待。
2. 在第二阶段，并不能确保所有参与者都能够成功接收协调者的执行指令，并成功执行。如果发生这种情况，会导致系统中的节点之间的数据存在不一致情况。	 

#### 2 3PC算法

由于2PC算法存在诸多问题，因此人们又提出了3PC算法，3PC算法和2PC一样，也是分布式系统中存在一个协调者和多个参与者，协调者和参与者的角色和2PC一样。

3PC算法的主要思想就是，将整个事务分成三个阶段来进行：  
- 1阶段（canCommit阶段）：协调者向所有参与者发送带超时时间的请求，询问参与者是否可以执行某个任务。 参与者收到请求之后，根据实际情况向协调者做出带有超时时间的响应，可以执行返回YES，不可以执行返回NO  
- 2阶段（preCommit阶段）：协调者收到所有参与者的响应，且均为YES，则执行预提交工作；如果收到的响应中有NO或者等待超时，则中断本次任务。
  - 均为YES，协调者向每个参与者发送preCommit命令，参与者收到事务预提交任务之后，执行事务操作，并将其写入到操作日志中，但是并不提交事务；本阶段如果执行成功，向协调者发送OK响应，失败或者实际不能执行则发送NO响应，响应都是带有超时时间的，发送完响应之后等待协调者接下来的指令。 
  - 响应中存在NO或者等待超时，那么协调者向每个参与者发送事务中断请求，参与者发送完`canCommit`响应之后，等到超时或者收到协调者发送过来的中断事务请求之后，均会中断本次事务。**本次事务结束**  
- 3阶段（doCommit阶段）：协调者收到参与者的响应，且均为OK，则想参与者发送doCommit请求；如果收到的响应中存在NO或者等待超时，则中断事务
  - 均为OK，那么向所有参与者发送doCommit请求，参与者收到doCommit请求之后，执行事务提交工作。**或者参与者在`preCommit`阶段发送完OK等待超时之后，也会默认执行事务提交工作**  。**本次事务结束**
  - 收到的响应中存在NO或者等待超时之后，那么协调者会向每个参与者发送事务中断请求，参与者在收到事务中断请求或者等待超时之后，执行回滚操作，并且释放事务期间占用的资源。**本次事务结束**
  - 

3PC算法相比于2PC算法，一是减少了阻塞的范围，因为整个事务的阶段分得更细；二是减少了单点故障，因为在`doCommit`阶段，如果参与者的响应是OK的话，此时即使协调者出现故障，参与者也会在等待超时后自动提交事务。

3PC并不能彻底解决数据一致性问题，原因如下：

在`doCommit`阶段，如果之前参与者的响应是OK的话，参与者在等待超时后，会自动执行事务。这必然会有可能导致整个系统的数据出现不一致情况。