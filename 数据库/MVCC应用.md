MVCC全称多版本并发控制。

主要原理就是对于同一份数据，在数据库中存储多份，每一份都是一个版本。然后根据事务发生的先后顺序，来决定哪些版本的数据对该事务可见，从而实现并发控制。

MVCC主要解决的是读写并发问题，可以在无锁情况下实现读写并发，从而可以提交读写效率。

关系型数据库中的读已提交、可重复读事务隔离等级就是基于MVCC实现的。

MVCC在mysql中的应用

mysql中的Innodb存储引擎支持MVCC，对于Innodb表，mysql会默认为表创建几个隐藏列，其中比较重要的就是

- tx_id ,事务id列，用于表明修改该行数据的事务id

- 回滚指针列，由于Innodb支持事务，且默认事务的隔离等级为可重复读，因此其内部对于一行数据，会存储多个版本，回滚指针用于指向在事务修改该行数据之前，该行数据的样子(即该行数据的上一个版本)，如下图所示，图片来自 [MySQL的多版本并发控制(MVCC)是什么？](https://segmentfault.com/a/1190000037557620)

  ![Undo Log回滚历史记录](https://github.com/guluo2016/picture/raw/dev/img/bVbyzV9)

mvcc是如何实现可重复读

mysql会按照事务的先后顺序，以严格递增方式为每一个事务分配一个唯一的事务id。

当mysql开启一个事务时，会立即形成一个快照，称之为read view,read view中记录了所有当前活跃的事务id。read view中的活跃事务集合中，存在一个最小id的事务，称之为low_tx_id, 存在一个最大事务id，high_tx_id。当前事务称之为cur_tx_id，假定cur_tx_id要读取的那行数据的隐藏事务列为tx_id，则可能存在如下几种情况。

**这里需要说明一点，当前事务id不一定是read view中的最大值，因为在开启事务时，生成read view之前，可能会有新的事务进来，这个时候就会出现read view中的rv_max_tx_id比当前事务id大的情况**

- cur_tx_id = tx_id，表示这行数据就是由当前事务修改的，必然对该事务可见
- tx_id < low_tx_id，表示在当前事务开启的时候，tx_id所代表的事务已经提交了，因此这行的该版本数据，对当前事务可见
- low_tx_id <= tx_id  <= high_tx_id, 且tx_id在read view集合中，表示当前事务开启时，tx_id事务还未提交，因此这行数据的这个版本对当前事务不可见
- low_tx_id <= tx_id  <= high_tx_id, 且tx_id不在read view集合中，表示当前事务开启时，tx_id事务已经提交，因此这行数据对当前事务可见
- tx_id > high_tx_id，表示tx_id事务是在当前事务开启之后提交的，因此数据对当前事务不可见

mvcc通过如上原理，再加上回滚指针，来实现可重复读。

当读取的数据版本，对当前事务可见时，则可以直接读取

当读取的数据版本，对当前事务不可见时，可按照改行的隐藏列回滚指针列，去读取这上数据的上一个版本（这个数据是存储在undo日志中的），直至满足条件为止。

MVCC实现读已提交

在读提提交隔离级别，MVCC遵循的规则和上面一直，不同的点是，在事务执行过程中，每一次的读操作，都会创建一个read view。

这样的话，read view不断更新，因此之前不可见的数据，随着对应事务的提交，也会对当前事务可见。

从而就实现了读已提交。

写写控制

MVCC实现了读写之前的无锁并发控制，而对于写写操作，Innodb表采用锁机制来进行并发控制，不过它采用的是行锁来进行控制，与表锁相比，它的粒度更细，锁定的范围更小，因此效率更高。



MVCC在HBase中的应用

MVCC不仅仅在关系型数据库中有所应用，在非关系型数据库，如HBase中，也应用到了MVCC。

HBase支持行级事务。当然HBase要想实现行级事务同样需要考虑写写控制、读写控制。如果不考虑这两种控制，可能会出现数据不一致情况，也就不是事务了。

写写控制

先考虑不进行并发控制的情况。

有两个写线程，同一时间段内，对一行数据进行修改，由于HBase的写入需要经过好两个步骤：

- 写WAL
- 写入memstore

如果不进行并发，那么在更新完WAL之后，可能第二个写线程先更新info:company,第一个写线程后更新info:company； 第一个线程先更新info:role，第二个线程后更新info:role，如下图所示。

![0002](https://github.com/guluo2016/picture/raw/dev/img/0002.png)

那么我们最终读取到的数据就是下面这样，即数据出现不一致。

![img](https://github.com/guluo2016/picture/raw/dev/img/1194e8c1-7a84-4da1-9953-1a6d74d07a4f)

为了解决上面的问题，HBase引入了行锁机制，以rowkey为锁，当写线程需要更新数据时，需要先获取行锁，然后才能更新，对于没有获取到行锁的写线程，只能等待，直至获取到行锁。

读写控制

读写场景，同样先考虑不进行并发控制，可能会出现的情况。

假如现在有两个写线程要更新同一行数据，同时一个读线程要对该行数据进行读取操作。读线程读取的时机是红线部分，此时第一个写线程已经完成，第二个写线程更新了一部分，如下图所示。

![img](https://github.com/guluo2016/picture/raw/dev/img/30530bc9-0305-47a1-a5c2-86281119799c)

那么读线程读取的数据就是下面这样子，同样会出现数据不一致情况。

![img](https://github.com/guluo2016/picture/raw/dev/img/1194e8c1-7a84-4da1-9953-1a6d74d07a4f)

为了解决上面的问题，HBas引入了MVCC机制，采用无锁机制，实现读写控制。为了实现该机制，HBase在进行写操作时，会进行如下操作：

- 获取行锁
- 分配一个写事务id
- 更新WAL
- 更新memstore
- 完成写事务id
- 释放锁

与此同时，对于每一次的读操作，HBase都会为其分配一个已经完成、且值最大的写事务id。

如图所示，两个写线程开启写事务时，HBase分别为其分配一个写id，当读事务开启时，由于写事务1已经完成，而写事务2还未完成，因此分配的已完成、其值最大的写事务id是1，称之为read point。因此对该读事务而言，所有小于等于read point的数据都是对其可见的，大于read point的数据是不可见的。

![image-20220815203852275](https://github.com/guluo2016/picture/raw/dev/img/image-20220815203852275.png)

因此，在这种情况下，读线程的最终读取结果是这个样子。

![img](https://github.com/guluo2016/picture/raw/dev/img/12b2c8a4-551b-4aa5-8629-874e220a91bd)