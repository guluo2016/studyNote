**Volatile**
---
### 1 为什么要用volatile关键字？
根据JMM，有主内存和工作内存的概念，主内存为所有线程所共享，里面存放线程共有的资源；工作内存为线程所私有。另外JMM规定了线程对变量的访问规则，即线程对变量的读写时，首先会将变量拷贝一个副本到自己所属的工作内存中，然后对该副本进行相关操作，然后由OS决定在合适的时间将副本刷新到主内存中。

副本刷新到主内存的时机由OS决定，在单线程环境下并没有什么问题，但是在多线程环境下，就不一定了。举个例子可以说明问题：（i是一个计数器）

```
boolean flag = false;

public void init(){   //线程A执行
	while(!flag){
	}

	dosomething();
}

public void setFlage(){  //线程B执行
	flag = true;
}
```

如上代码，假如线程A先执行，线程B后执行，那么可能出现的结果就是A一直处于死循环状态，原因在于线程A中的工作内存中存有一个flag的副本，其值是false，在其不断循环的过程中，每次都是从工作内存中查看数据；虽然后来线程B对flag进行修改，但是修改的是B工作内存中的flag值，它什么时候刷新到主内存中，谁也说不好，即使刷新到主内存中，线程A什么时候重新将其工作内存中的flag副本置为无效，重新从主内存中获取，也是不一定的，有可能一直不会那么此时A就会一直处于死循环状态了。

这个时候可不可以利用锁来实现flag的线程可见性，可以，但是不是最好方案，原因有两点：
1.增加代码量，使用锁需要创建一个同步方法，不停的检测flag的值，如果是false，那么释放锁之后再次重新检测，代码量大增
2.不断的上锁和释放锁，损失的性能太大，对于资源紧张型的程序，不可取

于是人们提出了使用volatile关键字

### 2 volatile关键字的好处？

对于volatile关键字修饰的变量，JMM规定，线程对其读写每次都是从主内存中获取值，当对该变量进行修改之后，JMM规定会要求OS立即将其刷新到主内存中，这样的话，其他线程在对该变量进行读写操作的时候，会首先从主内存中拿值，也就保证了拿到的值一定是最新的。

```
volatile boolean flag = false;

public void init(){   //线程A执行
	while(!flag){
	}

	dosomething();
}

public void setFlage(){  //线程B执行
	flag = true;
}
```

还以上面的那个代码为例，首先线程A陷入while循环，并且每次循环都会读flag进行一次读操作，这个时候它是直接从主内存中读取i的值；当线程B对flag修改之后，flag的值会立即刷新到主内存中，使得主内存中flag的值已经变成true；那么当线程A再次读flag操作的时候，就会发现flag=true，因此就会结束循环。

从上面可以看出，使用volatile关键字，可以有效解决变量的线程可见性问题，代码非常简洁，另外volatile的开销远远小于synchronized和Lock。

PS：面试中经常会问volatile修饰的i，执行i++是线程安全的吗？
不是线程安全的，原因在于：（i的初始值为1）i++可以分解为：

```
public synchronized int getI(){
	return i;   //直接返回主内存中的最新值
}  

public void addI(){
	int temp = getI();   
	int temp = temp +1;
	//此时让出CPU
	setI(temp);
}

public synchronized void setI(int i){
	this.i=i; //立即刷新到主内存中
}

```
从上面的代码可以看出，加入线程在执行完加1操作后，让出CPU（此时i还没有修改），那么i的值仍然为1，并没有刷新到主内存，此时另外一个线程也执行加1操作，刷新到主内存，此时i=2，之后第一个线程又获得CPU，将temp写入到i中，并立即刷新到主内存中，那么此时i=2，此时就线程不安全了。

原因在于i++并不是原子操作。

### 3 volatile关键字学习

#### 3.1 volatile的happens before规则
对于volatile变量的写操作，happens before于任意对该变量的读操作，如何理解？

这里的happens before并不是指的是时间上的先后，当两个线程A和B同时（同一时刻）对volatile变量进行操作的时候，假设A为写操作，B为读操作，那么这个是时候写操作happens before读操作，一直有个问题困惑我？后来看到有资料说，不管CPU是几核的，它于内存通信是通过总线进行的，而与总线通信的时候，是独占的，因此宏观上的并发，微观上实际上还是串行执行，这就保证了当多个线程对volatile变量的读写操作一定不会同一时刻进行，当冲突的时候，根据规则可以保证写操作先于读操作。
#### 3.2 volatile关键字的底层实现
为什么volatile变量能够保证线程每次读取的时候都是最新值？上面也说了，volatile规则使得变量的更新能够立即刷新到主内存中，保证了对数据变更的及时性，同时规定了对变量进行读操作的时候，每次都是从主内存中读取，这也避免了因工作内存中变量失效而引发的线程不安全问题，保证了每次拿到的数据都是最新值。

### 4 volatile的经典应用（ConcurrentHashMap.get()）
采用jdk1.7中的ConcurrentHashMap

