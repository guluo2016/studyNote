#### 跳表为什么适合合并操作

试想现在有两个特殊的数列（数据量很大，但是交集很小），如下所示，求两者的交集。

```shell
1. A = {1,2,3...10000}
2. B = {9998,99999,10001}
```

正常情况下，使用两个指针遍历这两个数组，

```java
int indexA = 0;
int indexB = 0;
List result = null;
while (indexA < A.length && indexB < B.length){
    if (A[indexA] == B[indexB]){
        result.add(A[indexA]);
        indexA ++; 
        indexB ++;
    }else if (A[indexA] > B[indexB]){
        indexB ++;
    }else {
        indexA ++;
    }
}
```

通过上面的代码可以看出来，常规方式取两个有序数列的交集，需要总共比较并移动指针`max(A.length，B.length) + 1`次。

对于这个常规方法，可以对其进行优化，从而减少比较和移动指针的次数。

优化办法：常规方法每次移动指针都是一步，我们可以适当的加大指针一次移动的步长。步长具体多少会合适呢，步长小的话，比较此处和移动的次数就会变多；步长大的话，比较次数和移动次数就会变少，但是可能会漏掉一些数据。为了合理规划步长，并且不漏掉数据，可以引入跳表的思想。

比较的时候，可以先在跳表索引的最高层进行移动，一旦发现步长过大，那么就进入下一层。

```shell
level2	1 --------------------------------------------------------->10000	
level1  1------------->1000-------------->2000----.. --------------->10000
level0  1-->100-->200-->...----------------------------------------->10000
data    1,2,3........................................................10000


level0	9998--------------------------------------------------------->10001
data    9998,9999,                                                    10001

1. 初始状态下：A在level2层，B在level0层,都在各自索引的最高层
2. Alevel2[0] < Blevel0[0],因此接下来比较Alevel2[1] 和Blevel0[0]
3. Alevel2[1] > Blevel0[0]，A的步长太大，有可能漏数据，回退，并进入索引的下一层，Alevel1
4. Alevel1[0] < Blevel0[0],因此接下来比较Alevel1[1]和Blevel0[0]
5. ...
6. 最终比较的是Alevel0[99]和Blevel0[0]，Alevel0[98]=10000,发现Alevel0[98]=9900比9998小，Alevel0[99]=10000比9998大，因此回退一步，进入下一层，到A的数据层
7. 最终比较A[9997]=9998，和Blevel0[0]相等，因此得到第一个数据，当前A步长为1，B步长为1,比较A的，均移动一次
8. 比较A的9999和Blevel0[1]相比，后者小，一次你B有可能漏掉数据，回退，并进入下一层数据层
9. 当前A步长为1，B步长为1,比较A的9999和B的9999，相等，再得到一个数据，继续移动
10. 比较A的10000和B的10001，发现前者小，A向前移动
11. 发现A已经到终点了，本次比较结束
```

通过上面的比较步骤可以发现，相比于常规手段，基于跳表的数据结构在进行交集计算的时候，可以有效减少比较及移动次数，从而可以提高效率。